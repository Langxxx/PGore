// Generated by gore. DO NOT EDIT!
// {{ entity.name }}+CoreDataProperties.swift

import Foundation
import CoreData
import AppaoKit

extension {{ entity.name }} {
    // attributes
    # for attribute in entity.attributes
    @NSManaged public var {{ attribute.name }}: {{ attribute.type }}{{ attribute.optional }}
    # endfor
    {{ '' }}
    // relationships
    # for relationship in entity.relationships
    # if relationship.to_many:
    @NSManaged public var {{ relationship.name }}: {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}
    # else
    @NSManaged public var {{ relationship.name }}: {{ relationship.destination_entity }}{{ relationship.optional }}
    # endif
    #endfor
}

// Keys
extension {{ entity.name }} {
    // attributes
    # for attribute in entity.attributes
    @nonobjc public static let {{ attribute.name }} = "{{ attribute.name }}"
    # endfor
    {{ '' }}
    // relationships
    # for relationship in entity.relationships
    @nonobjc public static let {{ relationship.name }} = "{{ relationship.name }}"
    #endfor
}

// for to-many relationship convenience
extension {{ entity.name }} {
    # for relationship in entity.relationships
    # if relationship.to_many
    func add{{ relationship.name[0].upper() + relationship.name[1:] }}Object(_ obj: {{ relationship.destination_entity }}) {
        let mutable = {{ relationship.name }}.mutableCopy() as! {% if relationship.ordered %}NSMutableOrderedSet{% else %}NSMutableSet{% endif %}
        mutable.add(obj)
        {{ relationship.name }} = mutable.copy() as! {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}
    }

    func remove{{ relationship.name[0].upper() + relationship.name[1:] }}Object(_ obj: {{ relationship.destination_entity }}) {
        let mutable = {{ relationship.name }}.mutableCopy() as! {% if relationship.ordered %}NSMutableOrderedSet{% else %}NSMutableSet{% endif %}
        mutable.remove(obj)
        {{ relationship.name }} = mutable.copy() as! {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}
    }
    # endif
    # endfor
}

#if entity.current_uniq_constraints
extension {{ entity.name }} {
    public class func fetchOrCreate({{ entity.current_uniq_constraints }}: String, in context: NSManagedObjectContext) -> Self {
        var create: Bool = false
        return _fetchOrCreate({{ entity.current_uniq_constraints }}: {{ entity.current_uniq_constraints }}, create: &create, in: context)
    }

    public class func fetchOrCreate({{ entity.current_uniq_constraints }}: String, create: inout Bool, in context: NSManagedObjectContext) -> Self {
        return _fetchOrCreate({{ entity.current_uniq_constraints }}: {{ entity.current_uniq_constraints }}, create: &create, in: context)
    }

    public class func fetch({{ entity.current_uniq_constraints }}: String, in context: NSManagedObjectContext) -> Self? {
        return _fetch({{ entity.current_uniq_constraints }}: {{ entity.current_uniq_constraints }}, in: context)
    }

    private class func _fetch<T: {{ entity.name }}>({{ entity.current_uniq_constraints }}: String, in context: NSManagedObjectContext) -> T? {
        return T.findOrFetch(in: context, predicate: Query.equal("{{ entity.current_uniq_constraints }}", {{ entity.current_uniq_constraints }}))
    }

    private class func _fetchOrCreate<T: {{ entity.name }}>({{ entity.current_uniq_constraints }}: String, create: inout Bool, in context: NSManagedObjectContext) -> T {
        guard let result = T.findOrFetch(in: context, predicate: Query.equal("{{ entity.current_uniq_constraints }}", {{ entity.current_uniq_constraints }})) else {
            let o = T.insertObject(in: context)
            o.{{ entity.current_uniq_constraints }} = {{ entity.current_uniq_constraints }}
            create = true
            return o
        }

        create = false
        return result
    }
}
#endif
{{ '' }}
// update or create from json
// NOTICE: Only model which have identifier attribute can update by identifier, otherwise this method will create new model
extension {{ entity.name }} {
    @discardableResult
    public {% if entity.parent_entity %}override {% endif %}class func updateOrCreate(from json: JSONResponse?, in context: NSManagedObjectContext, configration: (({{ entity.name }}, Bool) -> ())? = nil) -> {{ entity.name }}? {
        guard let json = json else {
            // log.warning("missing json when creating {{ entity.name }}")
            return nil
        }

        # if entity.uniq_constraints_with_parent
        // use identifier attribute to fetch first, if already exsit, just update it
        # for attribute in entity.all_attributes
        # if attribute.name == entity.uniq_constraints_with_parent
        if let {{ attribute.name }} = {{ attribute.json_value_expression }}, let obj = {{ entity.name }}.fetch({{ entity.uniq_constraints_with_parent }}: {{ entity.uniq_constraints_with_parent }}, in: context) {
            obj.update(from: json)
            configration?(obj, false)
            return obj
        }
        # endif
        # endfor
        # endif

        return create(from: json, in: context) {
            configration?($0, true)
        }
    }

    @discardableResult
    public {% if entity.parent_entity %}override {% endif %}class func create(from json: JSONResponse?, in context: NSManagedObjectContext, configration: (({{ entity.name }}) -> ())? = nil) -> {{ entity.name }}? {
        guard let json = json else {
            log.warning("missing json when creating {{ entity.name }}")
            return nil
        }

        # if entity.attributes
        ///////////////////////////////////////////////////////////////////////////////
        // check attributes if need
            # for attribute in entity.all_attributes
                # if not attribute.json_ignore
                    # if attribute.is_optional or attribute.default_value
        let {{ attribute.name }} = {{ attribute.json_value_expression }}
                    # else
        guard let {{ attribute.name }} = {{ attribute.json_value_expression }} else {
            log.warning("missing '{{ attribute.json_key }}'")
            return nil
        }
                    # endif
                # endif
            # endfor
        ///////////////////////////////////////////////////////////////////////////////
        # endif
        {{ '' }}
        # if entity.all_relationships
        ///////////////////////////////////////////////////////////////////////////////
        // check relationships if need
        # for relationship in entity.all_relationships
            # if relationship.json_value_expression
                #if relationship.to_many
        let {{ relationship.name }}: {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}
        if let json_{{ relationship.name }} = {{ relationship.json_value_expression }} {
            let array = json_{{ relationship.name }}.compactMap { {{ relationship.destination_entity }}.updateOrCreate(from: $0, in: context) }
            {{ relationship.name }} = {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}(array: array)
        } else {
            {{ relationship.name }} = {% if relationship.ordered %}NSOrderedSet{% else %}NSSet{% endif %}()
        }
                # else
                    # if relationship.is_optional
        let {{ relationship.name }} = {{ relationship.destination_entity }}.updateOrCreate(from: {{ relationship.json_value_expression }}, in: context)
                    # else
        guard let {{ relationship.name }} = {{ relationship.destination_entity }}.updateOrCreate(from: {{ relationship.destination_entity }}, in: context) else {
            log.warning("missing '{{ relationship.json_key }}'")
            return nil
        }
                    # endif
                # endif
            # endif
        # endfor
        ///////////////////////////////////////////////////////////////////////////////
        # endif
        {{ '' }}

        ///////////////////////////////////////////////////////////////////////////////
        // insert to context (already try fetched above if needed)
        let obj = {{ entity.name }}.insertObject(in: context)

        // assign attributes
        # for attribute in entity.attributes
        # if not attribute.json_ignore
        obj.{{ attribute.name }} = {{ attribute.name }}
        # endif
        # endfor

        # if entity.relationships
        // assign relationship
        # for relationship in entity.relationships
        # if relationship.json_value_expression
        obj.{{ relationship.name }} = {{ relationship.name }}
        # endif
        # endfor
        # endif
        {{ '' }}
        configration?(obj)

        return obj
    }
}

// update from json
extension {{ entity.name }} {
    # if entity.uniq_constraints_with_parent
    @discardableResult
    public {% if entity.parent_entity %}{% if entity.parent_entity_obj.current_uniq_constraints %}override {% endif %}{% endif %}class func update(from json: JSONResponse?, in context: NSManagedObjectContext) -> Bool {
        guard let json = json else {
            // log.warning("missing json")
            return false
        }

        # for attribute in entity.all_attributes
        # if attribute.name == entity.uniq_constraints_with_parent
        guard let {{ attribute.name }} = {{ attribute.json_value_expression }} else {
            log.warning("missing '{{ attribute.json_key }}'")
            return false
        }
        # endif
        # endfor

        guard let obj = {{ entity.name }}.fetch({{ entity.uniq_constraints_with_parent }}: {{ entity.uniq_constraints_with_parent }}, in: context) else {
            return false
        }

        return obj.update(from: json)
    }
    # endif

    @discardableResult
    public {% if entity.parent_entity %}override {% endif %}func update(from json: JSONResponse?) -> Bool {
        guard let json = json else {
            // log.warning("missing json")
            return false
        }

        # if entity.attributes
        # for attribute in entity.attributes
        # if not attribute.json_ignore
        if {{ attribute.json_expression }} != nil {
            #if attribute.is_optional
            self.{{ attribute.name }} = {{ attribute.json_value_expression }}
            #else
            if let {{ attribute.name }} = {{ attribute.json_value_expression_for_check_null }} {
                self.{{ attribute.name }} = {{ attribute.name }}
            } else {
                log.warning("'{{ attribute.json_key }}' is null or type-mismatch")
            }
            #endif
        }
        # endif
        # endfor
        #endif
        {{ '' }}
        if changedValues().count > 0 {
            log.info("[Gore] updated {{ entity.name }}{% if entity.uniq_constraints_with_parent %}[\({{ entity.uniq_constraints_with_parent }})]{% endif %}, changed: \(changedValues())")
        } else {
            // log.verbose("[Gore] updated nothing for {{ entity.name }}{% if entity.current_uniq_constraints %}[\({{ entity.current_uniq_constraints }})]{% endif %}")
        }
        return true
    }
}
